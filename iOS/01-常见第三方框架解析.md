# 常见第三方框架解析

标签（空格分隔）： iOS

---

## SDWebImage

### 加载图片的流程

- 区分图片是在本地还是在网络；
判断当前有没有任务正在运行 -> `loadImageWithUrl` ->加载完成后判断当前图片是否需要处理

- 加载时序图

![SDWebImageSequenceDiagram.png-128.8kB][1]

### 缓存模块

- 内存和磁盘双缓存
    - 内存缓存
        `SDMemoryCache` : NSCache， 而NSCache回收时机不受用户控制；
        SDMemoryCache首先会在NSCache中缓存；
        `if shouldUseWeakMemoryCache`；
        同步NSCache与SDMemoryCache；
        总结：
        - `NSMapTable`比NSDic拥有更多的内存语义（copy, assign, strong）；
    - 磁盘缓存
        1. 创建一个目录；
        2. 为每一个缓存文件生成一个MD5的文件名存放到目录中；
        3. 先去内存缓存中查找，若未找到，则生成一个新的NSOpertion；
    - 下载模块
    `SDWebImageDownloader`，管理类；`downloadImageWithUrl`
    `SDWebImageDownloaderOpertion`完成具体下载任务；
    `SDWebImageDownloaderLIFOExecutionOrder`管理下载任务优先级；
    

- `NSOpertion`
```
@interface NSOperation : NSObject {
@private
    id _private;
    int32_t _private1;
#if __LP64__
    int32_t _private1b;
#endif
}

// 开始操作
- (void)start;

// 操作任务的入口，一般用于自定义NSOperation的子类 
- (void)main;

// 判断是否已经被取消
@property (readonly, getter=isCancelled) BOOL cancelled;

// 取消操作Operation，调用后不会自动马上取消，需要通过isCancelled方法检查是否被取消，然后自己编写代码退出当前的Operation
- (void)cancel;

// 是否正在执行
@property (readonly, getter=isExecuting) BOOL executing;

// 是否执行完
@property (readonly, getter=isFinished) BOOL finished;

// 判定该线程是否是并发线程，即调用该operation的start方法的线程是否与operation所在线程相同
// 注意：此属性即将被弃用，之后使用asynchronous属性代替
@property (readonly, getter=isConcurrent) BOOL concurrent; // To be deprecated; use and override 'asynchronous' below

// 是否异步执行
@property (readonly, getter=isAsynchronous) BOOL asynchronous NS_AVAILABLE(10_8, 7_0);

// 是否准备好
// 在start方法开始之前，需要确定Operation是否准备好，默认为YES，如果该operation没有准备好，则不会start。
@property (readonly, getter=isReady) BOOL ready;

// 添加依赖关系，如：[op1 addDependency:op2]; op2先执行，op1后执行  
- (void)addDependency:(NSOperation *)op;

// 取消依赖，注意：操作对象的依赖不能在操作队列执行时取消
- (void)removeDependency:(NSOperation *)op;

// 获取有依赖关系的Operation所组成的数组
@property (readonly, copy) NSArray<NSOperation *> *dependencies;

// Operation优先级的枚举
typedef NS_ENUM(NSInteger, NSOperationQueuePriority) {
    NSOperationQueuePriorityVeryLow = -8L,
    NSOperationQueuePriorityLow = -4L,
    NSOperationQueuePriorityNormal = 0,
    NSOperationQueuePriorityHigh = 4,
    NSOperationQueuePriorityVeryHigh = 8
};

// 优先级
@property NSOperationQueuePriority queuePriority;

// Operation完成后调用的代码块
@property (nullable, copy) void (^completionBlock)(void) NS_AVAILABLE(10_6, 4_0);

// 堵塞当前线程，直到该Operation执行结束，才会执行接下来的代码
- (void)waitUntilFinished NS_AVAILABLE(10_6, 4_0);

// 设定Operation的线程优先级，取值范围0~1，默认为0.5
// 即使设定了线程优先级，也只能保证其在该线程的main()方法范围内有效，Operation的其他代码仍然执行在默认线程
@property double threadPriority NS_DEPRECATED(10_6, 10_10, 4_0, 8_0);

// 用于系统自动合理的管理队列的资源分配。
@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);

// 操作任务的名字
@property (nullable, copy) NSString *name NS_AVAILABLE(10_10, 8_0);

@end
```

- `NSIvocation`
```
    //NSInvocation;用来包装方法和对应的对象，它可以存储方法的名称，对应的对象，对应的参数,
    /*
     NSMethodSignature：签名：再创建NSMethodSignature的时候，必须传递一个签名对象，签名对象的作用：用于获取参数的个数和方法的返回值
     */
    //创建签名对象的时候不是使用NSMethodSignature这个类创建，而是方法属于谁就用谁来创建
    NSMethodSignature*signature = [ViewController instanceMethodSignatureForSelector:@selector(sendMessageWithNumber:WithContent:)];
    //1、创建NSInvocation对象
    NSInvocation*invocation = [NSInvocation invocationWithMethodSignature:signature];
    invocation.target = self;
    //invocation中的方法必须和签名中的方法一致。
    invocation.selector = @selector(sendMessageWithNumber:WithContent:);
    /*第一个参数：需要给指定方法传递的值
           第一个参数需要接收一个指针，也就是传递值的时候需要传递地址*/
    //第二个参数：需要给指定方法的第几个参数传值
    NSString*number = @"1111";
    //注意：设置参数的索引时不能从0开始，因为0已经被self占用，1已经被_cmd占用
    [invocation setArgument:&number atIndex:2];
    NSString*number2 = @"啊啊啊";
    [invocation setArgument:&number2 atIndex:3];
    //2、调用NSInvocation对象的invoke方法
    //只要调用invocation的invoke方法，就代表需要执行NSInvocation对象中制定对象的指定方法，并且传递指定的参数
    [invocation invoke];
```

## HTTP流程

1. 发送客户端SSL版本信息，random C，随机数算法；
2. 服务端返回客户端SSL版本，随机数random S等信息及服务器的公钥；（非对称加密由于耗时较长，只用于验证，而建立连接之后进行的通讯传输一般都是对称加密）
3. 客户端较验证书是否合法，并发送支持的对称加密方案；
4. 选择加密方式以明文方式发送给客户端；
5. 客户端产生Pre-Master，作为对称密钥，使用公钥加密进行通讯；

- 总结. 
ClientHello -> server hello -> 证书验证（客户端） -> pre-master（密钥：两个随机数加一pre master预主密钥）

`NSURLAuthenticationChallenge`：
`NSURLProtectionSpace`：一个容器，存储从服务器返回来的信息；
`authenticationMethod`：授权方式；
`SecTrustRef`：`serverTrust`，待验证的对象，要验证的证书以及支持的验证方法；
`SecTrustEvaluate`：证书校验函数，证书链，需要递归验证；
`NSURLCredential`：存储服务器建议使用的证书；
`BasicX509`：一种经典的验证策略；

200验证通过；

```
SecTrustRef ref = challenge.protectionSpace.serverTrust;
SecTrustResultType resultType;
NSURLCredential *urlCredential = nil;

OSStatus statue = SecTrustEvaluate(ref, &resultType)
```
1. 握手过程：验证服务端和客户端的身份，协商后续传输使用的密钥；
2. 数据传输过程：使用协商好的密钥进行通讯；


## NSURLSession

> 支持的协议（例如http）
授权和证书（例如服务器要求提供用户名密码）
cookie 存储（例如不存储cookie）
cache 管理（例如只在内存cache，不cache到硬盘）
配置管理（例如http headers等配置信息）

![20150321075126656.png-178.3kB][2]

[参考网址学习](https://blog.csdn.net/hello_hwc/article/details/44513699)

- AFNetworking

`AFAutoPurgingImageCache`
`AFImageCache`

- Alamofire


## 图片相关

- `YYImage`
GIF,PNG,JPEG,BMP,TIFF,WebP
PNG -> 89 50 4E 47
    - 支持以下类型动画图像的播放/编码/解码:
    WebP, APNG, GIF。
    - 支持以下类型静态图像的显示/编码/解码:
    WebP, PNG, GIF, JPEG, JP2, TIFF, BMP, ICO, ICNS。
    - 支持以下类型图片的渐进式/逐行扫描/隔行扫描解码:
    PNG, GIF, JPEG, BMP。
    - 支持多张图片构成的帧动画播放，支持单张图片的 sprite sheet 动画。
    - 高效的动态内存缓存管理，以保证高性能低内存的动画播放。
    - 完全兼容 UIImage 和 UIImageView，使用方便。
    - 保留可扩展的接口，以支持自定义动画。

- 加载动图的原理
`YYAnimatedImageView`负责播放动图;
`CADisplayLink`;



  [1]: http://static.zybuluo.com/usiege/zsqk4xbriv0akoia0p15r2d0/SDWebImageSequenceDiagram.png
  [2]: http://static.zybuluo.com/usiege/4tgr7yvf6c35lbrigs6i17ya/20150321075126656.png