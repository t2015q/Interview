# 底层探索

标签（空格分隔）： iOS

---

## sel与imp的关系

`runtime`是由C/C++/汇编共同写成提供运行时功能；
对象的本质是结构体；
```
//method -> (id self, SEL _cmd)
//IMP:指向函数具体实现的指针
//由sel -> imp
//objc_msgSend -> libobjc
```
[苹果源码搜索](http://opensource.apple.com)

### objc_msgSend

`objc-msg-arm64.s`: `CacheLookup`：寻找有缓存机制；

- `CheckHit`找到缓存 -> 从寄存器里获取；
- `CheckMiss`没有找到缓存 -> `_objc_msgSend_uncached` -> `MethodTableLookup` -> `__class_lookupMethodAndLoadCache`；
- `add`没有缓存添加到缓存，方便下次从缓存中搜索；


对象 -> 结构体 -> Class 包含方法列表，属性列表，协议列表；

方法的查找流程包含快速查找以及慢速查找，以上由汇编写成，属于快速查找过程。

### 慢速查找过程

`objc-class-old.mm`旧，`objc-runtime-new.mm`新:

`_class_lookupMethodAndLoadCache(id obj, SEL sel, Class cls)`寻找IMP

`lookUpImpOrForward`:
```
IMP imp = nil;
bool triedResolver = NO;

runtimeLock.assertUnlocked();

if (cache){
    imp = cache_getImp(cls, sel);
    if imp return imp;
}

runtimeLock.lock();
checkIsKnownClass(cls);

Method meth = getMethodNoSuper_nolock(cls, sel);
imp = meth.imp;

imp = (IMP)_objc_msgForward_impcache(cls, sel);
```

- 实例对象，cls类对象，元类对象
实例方法存储在类对象MethodList，类对象的方法存储在元类对象中；
方法查找，先在自己类的方法列表中查找，`log_and_fill_cache`，递归到父类方法列表中查找；

分类可以添加源代码中未实现的方法；

![方法查找流程.png-359.7kB][1]

### 动态方法解析与消息转发

`void _class_resolveMethod(Class cls, SEL sel, id inst)`
在上面的方法中，进行动态方法解析；

`resolveInstanceMethod:`

先判断是否是元类方法，实例方法与类方法将会分开进行讨论；
![消息转发流程.png-681kB][2]

动态解析失败，进行消息转发；

`forwardingTargetForSelector:`

`methodSignatureForSelector:`

```
Method method = class_getInstanceMethod([self class], @selector(aFunc));
const char *type = method_getTypeEncoding(method);
return [NSMethodSignature signatureWithObjCTypes:type];
```

```
- (void)forwardInvocation:(NSInvocation *)anInvocation{
    anInvocation.selector = @selector(aFunc);
    [anInvocation invoke];
}
```
PS：aspect 切面编程是什么？
```
int __forwarding__(void *frameStackPointer, int isStret) {
    id receiver = *(id *)frameStackPointer;
    SEL sel = *(SEL *)(frameStackPointer + 8);
    const char *selName = sel_getName(sel);
    Class receiverClass = object_getClass(receiver);
    
    // 调用 forwardingTargetForSelector:
    if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) {
        id forwardingTarget = [receiver forwardingTargetForSelector:sel];
        if (forwardingTarget && forwarding != receiver) {
            if (isStret == 1) {
                int ret;
                objc_msgSend_stret(&ret,forwardingTarget, sel, ...);
                return ret;
            }
            return objc_msgSend(forwardingTarget, sel, ...);
        }
    }
    
    // 僵尸对象
    const char *className = class_getName(receiverClass);
    const char *zombiePrefix = "_NSZombie_";
    size_t prefixLen = strlen(zombiePrefix); // 0xa
    if (strncmp(className, zombiePrefix, prefixLen) == 0) {
        CFLog(kCFLogLevelError,
              @"*** -[%s %s]: message sent to deallocated instance %p",
              className + prefixLen,
              selName,
              receiver);
        <breakpoint-interrupt>
    }
    
    // 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation
    if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) {
        NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel];
        if (methodSignature) {
            BOOL signatureIsStret = [methodSignature _frameDescriptor]->returnArgInfo.flags.isStruct;
            if (signatureIsStret != isStret) {
                CFLog(kCFLogLevelWarning ,
                      @"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'.  Signature thinks it does%s return a struct, and compiler thinks it does%s.",
                      selName,
                      signatureIsStret ? "" : not,
                      isStret ? "" : not);
            }
            if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) {
                NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];
                
                [receiver forwardInvocation:invocation];
                
                void *returnValue = NULL;
                [invocation getReturnValue:&value];
                return returnValue;
            } else {
                CFLog(kCFLogLevelWarning ,
                      @"*** NSForwarding: warning: object %p of class '%s' does not implement forwardInvocation: -- dropping message",
                      receiver,
                      className);
                return 0;
            }
        }
    }
    
    SEL *registeredSel = sel_getUid(selName);
    
    // selector 是否已经在 Runtime 注册过
    if (sel != registeredSel) {
        CFLog(kCFLogLevelWarning ,
              @"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort",
              sel,
              selName,
              registeredSel);
    } // doesNotRecognizeSelector
    else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) {
        [receiver doesNotRecognizeSelector:sel];
    }
    else {
        CFLog(kCFLogLevelWarning ,
              @"*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector: -- abort",
              receiver,
              className);
    }
    
    // The point of no return.
    kill(getpid(), 9);
}
```

## Weak

### 散列表 SideTable

- 自旋锁 `spinlock`
- 引用计数 `RefcountMap`
- 弱引用表 `weak_table_t`

![image_1e8sl43ghcderq813kq1hpm1ims11.png-109.5kB][4]

```
NSObject *objc1 = [[NSObject alloc] init];
id __weak objc2 = objc1;
```

`objc_initWeak`中利用散列表对weak对象进行管理；
`objc_dealloc`；



## Runtime API

```
// 1.objc_xxx 系列函数
// 函数名称     函数作用
objc_getClass     获取Class对象
objc_getMetaClass     获取MetaClass对象
objc_allocateClassPair     分配空间,创建类(仅在 创建之后,注册之前 能够添加成员变量)
objc_registerClassPair     注册一个类(注册后方可使用该类创建对象)
objc_disposeClassPair     注销某个类
objc_allocateProtocol     开辟空间创建协议
objc_registerProtocol     注册一个协议
objc_constructInstance     构造一个实例对象(ARC下无效)
objc_destructInstance     析构一个实例对象(ARC下无效)
objc_setAssociatedObject     为实例对象关联对象
objc_getAssociatedObje*ct     获取实例对象的关联对象
objc_removeAssociatedObjects     清空实例对象的所有关联对象


objc_系列函数关注于宏观使用,如类与协议的空间分配,注册,注销等操作

// 2.class_xxx 系列函数
函数名称     函数作用
class_addIvar     为类添加实例变量
class_addProperty     为类添加属性
class_addMethod     为类添加方法
class_addProtocol     为类遵循协议
class_replaceMethod     替换类某方法的实现
class_getName     获取类名
class_isMetaClass     判断是否为元类
objc_getProtocol     获取某个协议
objc_copyProtocolList     拷贝在运行时中注册过的协议列表
class_getSuperclass     获取某类的父类
class_setSuperclass     设置某类的父类
class_getProperty     获取某类的属性
class_getInstanceVariable     获取实例变量
class_getClassVariable     获取类变量
class_getInstanceMethod     获取实例方法
class_getClassMethod     获取类方法
class_getMethodImplementation     获取方法的实现
class_getInstanceSize     获取类的实例的大小
class_respondsToSelector     判断类是否实现某方法
class_conformsToProtocol     判断类是否遵循某协议
class_createInstance     创建类的实例
class_copyIvarList     拷贝类的实例变量列表
class_copyMethodList     拷贝类的方法列表
class_copyProtocolList     拷贝类遵循的协议列表
class_copyPropertyList     拷贝类的属性列表

-

class_系列函数关注于类的内部,如实例变量,属性,方法,协议等相关问题

// 3.object_xxx 系列函数
函数名称     函数作用
object_copy     对象copy(ARC无效)
object_dispose     对象释放(ARC无效)
object_getClassName     获取对象的类名
object_getClass     获取对象的Class
object_setClass     设置对象的Class
object_getIvar     获取对象中实例变量的值
object_setIvar     设置对象中实例变量的值
object_getInstanceVariable     获取对象中实例变量的值 (ARC中无效,使用object_getIvar)
object_setInstanceVariable     设置对象中实例变量的值 (ARC中无效,使用object_setIvar)

-

objcet_系列函数关注于对象的角度,如实例变量

// 4.method_xxx 系列函数
函数名称     函数作用
method_getName     获取方法名
method_getImplementation     获取方法的实现
method_getTypeEncoding     获取方法的类型编码
method_getNumberOfArguments     获取方法的参数个数
method_copyReturnType     拷贝方法的返回类型
method_getReturnType     获取方法的返回类型
method_copyArgumentType     拷贝方法的参数类型
method_getArgumentType     获取方法的参数类型
method_getDescription     获取方法的描述
method_setImplementation     设置方法的实现
method_exchangeImplementations     替换方法的实现

-

method_系列函数关注于方法内部,如果方法的参数及返回值类型和方法的实现

// 5.property_xxx 系列函数
函数名称     函数作用
property_getName     获取属性名
property_getAttributes     获取属性的特性列表
property_copyAttributeList     拷贝属性的特性列表
property_copyAttributeValue     拷贝属性中某特性的值

-

property_系类函数关注与属性*内部,如属性的特性等

// 6.protocol_xxx 系列函数
函数名称     函数作用
protocol_conformsToProtocol     判断一个协议是否遵循另一个协议
protocol_isEqual     判断两个协议是否一致
protocol_getName     获取协议名称
protocol_copyPropertyList     拷贝协议的属性列表
protocol_copyProtocolList     拷贝某协议所遵循的协议列表
protocol_copyMethodDescriptionList     拷贝协议的方法列表
protocol_addProtocol     为一个协议遵循另一协议
protocol_addProperty     为协议添加属性
protocol_getProperty     获取协议中的某个属性
protocol_addMethodDescription     为协议添加方法描述
protocol_getMethodDescription     获取协议中某方法的描述

// 7.ivar_xxx 系列函数
函数名称     函数作用
ivar_getName     获取Ivar名称
ivar_getTypeEncoding     获取类型编码
ivar_getOffset     获取偏移量

// 8.sel_xxx 系列函数
函数名称     函数作用
sel_getName     获取名称
sel_getUid     注册方法
sel_registerName     注册方法
sel_isEqual     判断方法是否相等

// 9.imp_xxx 系列函数
函数名称     函数作用
imp_implementationWithBlock     通过代码块创建IMP
imp_getBlock     获取函数指针中的代码块
imp_removeBlock     移除IMP中的代码块
```


  [1]: http://static.zybuluo.com/usiege/e7tggpx00o1upykjvrhw2k3s/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E6%B5%81%E7%A8%8B.png
  [2]: http://static.zybuluo.com/usiege/0ukq7mw0rnd6xv9wc56qgxgm/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B.png
  [3]: http://static.zybuluo.com/usiege/ag3j6dcti6rl721o9pw5hciq/image_1e8sl8fn5o8cbq31ers1ill4e81e.png
  [4]: http://static.zybuluo.com/usiege/ipu5u59kmy9rz4mh4xsptady/image_1e8sl43ghcderq813kq1hpm1ims11.png